# Recolector de fuentes

- Fecha de generaciÃ³n: 2026-01-06 20:34:28
- RaÃ­z: `/mnt/DocumentosJC/proyectos/python/backend/fastapi/api/clientes_api`
- Archivo de salida: `repositorio.txt` (chunk 1/1)

## Ãrbol de archivos incluidos

```text

```

## Ãndice global (archivo â†’ chunk)

- [001] .env.back
- [001] .gitignore
- [001] app/auth/deps.py
- [001] app/auth/jwt.py
- [001] app/auth/passwords.py
- [001] app/core/config.py
- [001] app/database.py
- [001] app/main.py
- [001] app/repository/users_repo.py
- [001] app/routers/auth.py
- [001] app/routers/clientes.py
- [001] app/routers/clientes_old.py
- [001] app/schemas/auth.py
- [001] app/schemas/cliente.py
- [001] docs/init_db.sql
- [001] README.md
- [001] requirements.txt

## Archivos omitidos (razones)

### excluded_name_or_ext
- .env

---

README.md
-----
```markdown
# ğŸš€ API REST de GestiÃ³n de Clientes con AutenticaciÃ³n JWT

> **Proyecto Educativo** - FastAPI + MySQL + JWT Authentication
> 
> Ãšltima actualizaciÃ³n: 6 de enero de 2026

## ğŸ“‹ Tabla de Contenidos

1. [DescripciÃ³n General](#-descripciÃ³n-general)
2. [CaracterÃ­sticas Principales](#-caracterÃ­sticas-principales)
3. [Arquitectura del Proyecto](#-arquitectura-del-proyecto)
4. [TecnologÃ­as Utilizadas](#-tecnologÃ­as-utilizadas)
5. [Estructura del Proyecto](#-estructura-del-proyecto)
6. [Requisitos Previos](#-requisitos-previos)
7. [InstalaciÃ³n y ConfiguraciÃ³n](#-instalaciÃ³n-y-configuraciÃ³n)
8. [EjecuciÃ³n del Proyecto](#-ejecuciÃ³n-del-proyecto)
9. [API Endpoints](#-api-endpoints)
10. [Sistema de AutenticaciÃ³n](#-sistema-de-autenticaciÃ³n)
11. [Control de Acceso Basado en Roles](#-control-de-acceso-basado-en-roles)
12. [Validaciones y Schemas](#-validaciones-y-schemas)
13. [Base de Datos](#-base-de-datos)
14. [DocumentaciÃ³n Interactiva](#-documentaciÃ³n-interactiva)
15. [Buenas PrÃ¡cticas Implementadas](#-buenas-prÃ¡cticas-implementadas)
16. [SoluciÃ³n de Problemas](#-soluciÃ³n-de-problemas)

---

## ğŸ“– DescripciÃ³n General

Este proyecto es una **API REST profesional** desarrollada con **FastAPI** que implementa un sistema completo de gestiÃ³n de clientes con autenticaciÃ³n JWT y control de acceso basado en roles. 

### ğŸ¯ Finalidad Educativa

DiseÃ±ado especÃ­ficamente para estudiantes de **Desarrollo de Aplicaciones Web** y **Desarrollo de Aplicaciones Multiplataforma**, este proyecto demuestra:

âœ… **Arquitectura moderna de APIs REST**
- SeparaciÃ³n completa Backend/Frontend
- Arquitectura en capas (Layered Architecture)
- DiseÃ±o modular y escalable

âœ… **Seguridad implementada profesionalmente**
- AutenticaciÃ³n OAuth2 con JWT
- Hash de contraseÃ±as con bcrypt
- Control de acceso basado en roles (RBAC)
- ProtecciÃ³n de endpoints sensibles

âœ… **Mejores prÃ¡cticas de desarrollo**
- ValidaciÃ³n robusta de datos con Pydantic
- Manejo apropiado de errores HTTP
- DocumentaciÃ³n automÃ¡tica con OpenAPI/Swagger
- Variables de entorno para configuraciÃ³n

---

## âœ¨ CaracterÃ­sticas Principales

### ğŸ” AutenticaciÃ³n y AutorizaciÃ³n
- **Login con JWT**: Sistema OAuth2 Password Flow compatible con Swagger UI
- **Tokens de acceso**: JWT firmados con expiraciÃ³n configurable
- **Dos roles de usuario**: 
  - `admin`: CRUD completo sobre clientes
  - `lector`: Solo lectura de clientes
- **ProtecciÃ³n de endpoints**: Middleware de autenticaciÃ³n y autorizaciÃ³n

### ğŸ“Š GestiÃ³n de Clientes
- **CRUD completo**: Crear, leer, actualizar y eliminar clientes
- **Validaciones exhaustivas**: Email, telÃ©fono, nombres con regex
- **Endpoints pÃºblicos**: Lectura de clientes sin autenticaciÃ³n
- **Endpoints protegidos**: Escritura/modificaciÃ³n requiere rol admin

### ğŸ› ï¸ CaracterÃ­sticas TÃ©cnicas
- **CORS configurado**: Listo para integraciÃ³n con frontends
- **Manejo de errores**: Respuestas HTTP apropiadas para cada situaciÃ³n
- **DocumentaciÃ³n interactiva**: Swagger UI y ReDoc automÃ¡ticos
- **Base de datos MySQL**: Con Ã­ndices y restricciones apropiadas

---

## ğŸ—ï¸ Arquitectura del Proyecto

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CLIENTE (Frontend)                   â”‚
â”‚    React / Vue / Angular / Mobile            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ HTTP/JSON + JWT Bearer
                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CAPA DE PRESENTACIÃ“N (Routers)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Auth Router â”‚      â”‚ Clientes     â”‚      â”‚
â”‚  â”‚ /auth/login â”‚      â”‚ Router       â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ /clientes    â”‚      â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CAPA DE SEGURIDAD (Auth)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ JWT Handler  â”‚  â”‚ Dependencies   â”‚       â”‚
â”‚  â”‚ â€¢ create     â”‚  â”‚ â€¢ require_adminâ”‚       â”‚
â”‚  â”‚ â€¢ decode     â”‚  â”‚ â€¢ get_current  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CAPA DE VALIDACIÃ“N (Schemas)              â”‚
â”‚  â€¢ ClienteCreate    â€¢ ClienteUpdate          â”‚
â”‚  â€¢ ClienteResponse  â€¢ EmailStr               â”‚
â”‚  â€¢ Field validators con regex                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CAPA DE LÃ“GICA (Database + Repository)    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ database.py    â”‚  â”‚ users_repo   â”‚       â”‚
â”‚  â”‚ â€¢ CRUD clientesâ”‚  â”‚ â€¢ get_user   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CAPA DE DATOS (MySQL)                     â”‚
â”‚  â€¢ clientes    â€¢ usuarios    â€¢ roles         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ventajas de esta Arquitectura:

- âœ… **SeparaciÃ³n de responsabilidades**: Cada capa tiene una funciÃ³n especÃ­fica
- âœ… **Mantenibilidad**: FÃ¡cil de modificar y extender
- âœ… **ReutilizaciÃ³n**: El backend puede servir mÃºltiples frontends
- âœ… **Escalabilidad**: Se puede escalar cada capa independientemente
- âœ… **Testabilidad**: Cada capa se puede probar de forma aislada

---

## ğŸ› ï¸ TecnologÃ­as Utilizadas

| TecnologÃ­a | VersiÃ³n | PropÃ³sito |
|-----------|---------|-----------|
| **Python** | 3.12+ | Lenguaje de programaciÃ³n principal |
| **FastAPI** | 0.128.0 | Framework web moderno y de alto rendimiento |
| **Pydantic** | 2.12.5 | ValidaciÃ³n de datos y serializaciÃ³n |
| **MySQL Connector** | 9.5.0 | Driver para conexiÃ³n con MySQL |
| **Uvicorn** | 0.40.0 | Servidor ASGI para ejecutar FastAPI |
| **Python-dotenv** | 1.2.1 | GestiÃ³n de variables de entorno |
| **Email-validator** | 2.3.0 | ValidaciÃ³n de direcciones de email |
| **Python-Jose** | 3.5.0 | GeneraciÃ³n y verificaciÃ³n de JWT |
| **Passlib** | 1.7.4 | Hash seguro de contraseÃ±as |
| **Bcrypt** | 3.2.2 | Algoritmo de hashing para passwords |
| **Python-multipart** | 0.0.21 | Procesamiento de datos de formulario |

### Dependencias de Desarrollo
- **Black** | 25.12.0 | Formateador de cÃ³digo Python

---

## ğŸ“ Estructura del Proyecto

```
clientes_api/
â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # Punto de entrada de la aplicaciÃ³n
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ config.py           # ConfiguraciÃ³n centralizada (SECRET_KEY, JWT)
â”‚   â”‚
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ jwt.py              # CreaciÃ³n y decodificaciÃ³n de JWT
â”‚   â”‚   â”œâ”€â”€ passwords.py        # Hash y verificaciÃ³n de contraseÃ±as
â”‚   â”‚   â””â”€â”€ deps.py             # Dependencias de autenticaciÃ³n/autorizaciÃ³n
â”‚   â”‚
â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â”œâ”€â”€ auth.py             # Endpoint de login OAuth2
â”‚   â”‚   â””â”€â”€ clientes.py         # CRUD de clientes (pÃºblico + protegido)
â”‚   â”‚
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ auth.py             # Schemas de autenticaciÃ³n
â”‚   â”‚   â””â”€â”€ cliente.py          # Schemas de validaciÃ³n de clientes
â”‚   â”‚
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â””â”€â”€ users_repo.py       # Consultas de usuarios para auth
â”‚   â”‚
â”‚   â””â”€â”€ database.py             # Funciones CRUD y conexiÃ³n MySQL
â”‚
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ init_db.sql             # Script de inicializaciÃ³n de BD
â”‚
â”œâ”€â”€ .env                        # Variables de entorno (NO INCLUIR EN GIT)
â”œâ”€â”€ .env.example                # Plantilla de variables de entorno
â”œâ”€â”€ requirements.txt            # Dependencias del proyecto
â””â”€â”€ README.md                   # Este archivo

```

---

## ğŸ“‹ Requisitos Previos

Antes de comenzar, asegÃºrate de tener instalado:

- âœ… **Python 3.12 o superior**
  ```bash
  python --version
  ```

- âœ… **MySQL Server 8.0 o superior**
  ```bash
  mysql --version
  ```

- âœ… **pip** (gestor de paquetes de Python)
  ```bash
  pip --version
  ```

- âœ… **Git** (opcional, para clonar el repositorio)

---

## âš™ï¸ InstalaciÃ³n y ConfiguraciÃ³n

### 1ï¸âƒ£ Clonar o Descargar el Proyecto

```bash
git clone <url-del-repositorio>
cd clientes_api
```

### 2ï¸âƒ£ Crear y Activar Entorno Virtual

**Linux/Mac:**
```bash
python -m venv .venv
source .venv/bin/activate
```

**Windows:**
```cmd
python -m venv .venv
.venv\Scripts\activate
```

### 3ï¸âƒ£ Instalar Dependencias

```bash
pip install -r requirements.txt
```

### 4ï¸âƒ£ Configurar Base de Datos MySQL

**a) Crear la base de datos:**
```bash
mysql -u root -p < docs/init_db.sql
```

**b) Verificar que se crearon las tablas:**
```bash
mysql -u root -p
```
```sql
USE clientes_db;
SHOW TABLES;
-- Debe mostrar: clientes, roles, usuarios
```

### 5ï¸âƒ£ Configurar Variables de Entorno

**a) Crear archivo `.env` en la raÃ­z del proyecto:**
```bash
cp .env.example .env
```

**b) Editar `.env` con tus credenciales:**
```env
# Database Configuration
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=tu_password_mysql
DB_NAME=clientes_db

# JWT Configuration
SECRET_KEY=tu_clave_secreta_super_segura_aqui_cambiala
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=60
```

> âš ï¸ **IMPORTANTE**: Genera una SECRET_KEY Ãºnica usando:
> ```bash
> python -c "import secrets; print(secrets.token_hex(32))"
> ```

---

## ğŸš€ EjecuciÃ³n del Proyecto

### Modo Desarrollo (con auto-reload)

```bash
uvicorn app.main:app --reload
```

La API estarÃ¡ disponible en: **http://127.0.0.1:8000**

### Configurar Alias (Opcional)

Si usas Linux/Mac, puedes crear un alias en tu shell:

**Bash (~/.bashrc):**
```bash
alias py-uvi-app="uvicorn app.main:app --reload"
```

**Luego simplemente ejecuta:**
```bash
py-uvi-app
```

---

## ğŸ“ API Endpoints

### ğŸ” AutenticaciÃ³n

| MÃ©todo | Endpoint | DescripciÃ³n | Auth | Rol |
|--------|----------|-------------|------|-----|
| `POST` | `/auth/login` | Login y generaciÃ³n de JWT | No | - |

**Request (Form Data):**
```json
{
  "username": "admin",
  "password": "admin123"
}
```

**Response:**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer"
}
```

### ğŸ‘¥ GestiÃ³n de Clientes

| MÃ©todo | Endpoint | DescripciÃ³n | Auth | Rol |
|--------|----------|-------------|------|-----|
| `GET` | `/clientes/` | Listar todos los clientes | No | - |
| `GET` | `/clientes/{id}` | Obtener cliente por ID | No | - |
| `POST` | `/clientes/` | Crear nuevo cliente | SÃ­ | Admin |
| `PUT` | `/clientes/{id}` | Actualizar cliente | SÃ­ | Admin |
| `DELETE` | `/clientes/{id}` | Eliminar cliente | SÃ­ | Admin |

### Ejemplos de Uso

**1. Listar clientes (pÃºblico):**
```bash
curl http://127.0.0.1:8000/clientes/
```

**2. Login:**
```bash
curl -X POST "http://127.0.0.1:8000/auth/login" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=admin123"
```

**3. Crear cliente (requiere token):**
```bash
curl -X POST "http://127.0.0.1:8000/clientes/" \
  -H "Authorization: Bearer TU_TOKEN_AQUI" \
  -H "Content-Type: application/json" \
  -d '{
    "nombre": "Pedro",
    "apellido": "GonzÃ¡lez",
    "email": "pedro@example.com",
    "telefono": "+34612345678",
    "direccion": "Calle Principal 123"
  }'
```

---

## ğŸ” Sistema de AutenticaciÃ³n

### Flujo de AutenticaciÃ³n

1. **Login**: Usuario envÃ­a `username` y `password` a `/auth/login`
2. **VerificaciÃ³n**: Sistema verifica credenciales contra la BD (hash bcrypt)
3. **GeneraciÃ³n JWT**: Se crea un token firmado con informaciÃ³n del usuario
4. **Respuesta**: Cliente recibe el token
5. **Uso**: Cliente incluye token en header `Authorization: Bearer <token>`
6. **ValidaciÃ³n**: Cada request protegido verifica y decodifica el JWT

### Estructura del JWT

```json
{
  "sub": "admin",           // username
  "role": "admin",          // rol del usuario
  "exp": 1704585600         // timestamp de expiraciÃ³n
}
```

### ImplementaciÃ³n de Seguridad

**Hash de contraseÃ±as:**
```python
# app/auth/passwords.py
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
```

**CreaciÃ³n de JWT:**
```python
# app/auth/jwt.py
from jose import jwt
from datetime import datetime, timedelta

def create_access_token(data: dict) -> str:
    expire = datetime.utcnow() + timedelta(minutes=60)
    to_encode = data.copy()
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm="HS256")
```

---

## ğŸ›¡ï¸ Control de Acceso Basado en Roles

### Roles Disponibles

| Rol | DescripciÃ³n | Permisos |
|-----|-------------|----------|
| **admin** | Administrador | CRUD completo de clientes |
| **lector** | Solo lectura | Solo GET endpoints |

### Usuarios de Prueba

| Username | Password | Rol |
|----------|----------|-----|
| `admin` | `admin123` | admin |
| `lector` | `lector123` | lector |

### ImplementaciÃ³n de AutorizaciÃ³n

**Dependencia `require_admin`:**
```python
# app/auth/deps.py
def require_admin(user: dict = Depends(get_current_user)) -> dict:
    if user["role"] != "admin":
        raise HTTPException(
            status_code=403,
            detail="Permisos insuficientes"
        )
    return user
```

**Uso en endpoints protegidos:**
```python
# app/routers/clientes.py
@router.post("/", dependencies=[Depends(require_admin)])
def crear_cliente(cliente: ClienteCreate):
    # Solo usuarios admin pueden ejecutar esto
    pass
```

---

## âœ… Validaciones y Schemas

### Schema de Cliente

```python
# app/schemas/cliente.py
class ClienteCreate(BaseModel):
    nombre: str          # 2-50 caracteres, solo letras
    apellido: str        # 2-50 caracteres, solo letras
    email: EmailStr      # ValidaciÃ³n automÃ¡tica de email
    telefono: str | None # Formato internacional (7-15 dÃ­gitos)
    direccion: str | None
```

### Validaciones Implementadas

**1. Nombres y Apellidos:**
- MÃ­nimo 2 caracteres, mÃ¡ximo 50
- Solo letras, espacios, tildes y caracteres espaÃ±oles (Ã±, Ã¼)
- Auto-capitalizaciÃ³n (Title Case)
- Regex: `^[a-zA-ZÃ¡Ã©Ã­Ã³ÃºÃÃ‰ÃÃ“ÃšÃ±Ã‘Ã¼Ãœ\s]+$`

**2. Email:**
- ValidaciÃ³n completa con `EmailStr` de Pydantic
- Verifica formato y dominio vÃ¡lido

**3. TelÃ©fono:**
- Formato internacional permitido
- 7-15 dÃ­gitos (puede incluir +, espacios, guiones, parÃ©ntesis)
- Se limpia automÃ¡ticamente antes de validar

**4. DirecciÃ³n:**
- Opcional
- MÃ¡ximo 255 caracteres

### Ejemplo de ValidaciÃ³n Exitosa

```json
{
  "nombre": "MarÃ­a JosÃ©",
  "apellido": "GarcÃ­a LÃ³pez",
  "email": "maria.garcia@example.com",
  "telefono": "+34 612 345 678",
  "direccion": "Av. Principal 123, Madrid"
}
```

### Ejemplo de Error de ValidaciÃ³n

```json
{
  "nombre": "M",  // âŒ Menos de 2 caracteres
  "apellido": "GarcÃ­a123",  // âŒ Contiene nÃºmeros
  "email": "no-es-email",  // âŒ Email invÃ¡lido
  "telefono": "123"  // âŒ Menos de 7 dÃ­gitos
}
```

**Respuesta HTTP 422:**
```json
{
  "detail": [
    {
      "loc": ["body", "nombre"],
      "msg": "Debe tener al menos 2 caracteres",
      "type": "value_error"
    }
  ]
}
```

---

## ğŸ—„ï¸ Base de Datos

### Esquema de Tablas

**Tabla `clientes`:**
```sql
CREATE TABLE clientes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL,
  apellido VARCHAR(100) NOT NULL,
  email VARCHAR(150) NOT NULL UNIQUE,
  telefono VARCHAR(50),
  direccion VARCHAR(255)
);
```

**Tabla `roles`:**
```sql
CREATE TABLE roles (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nombre VARCHAR(50) NOT NULL UNIQUE,
  descripcion VARCHAR(150)
);
```

**Tabla `usuarios`:**
```sql
CREATE TABLE usuarios (
  id INT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  email VARCHAR(150) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  rol_id INT NOT NULL,
  activo TINYINT NOT NULL DEFAULT 1,
  creado_en TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  actualizado_en TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (rol_id) REFERENCES roles(id)
);
```

### Datos Iniciales

El script `docs/init_db.sql` incluye:
- âœ… 5 clientes de ejemplo
- âœ… 2 roles (admin, lector)
- âœ… 2 usuarios de prueba con contraseÃ±as hasheadas

---

## ğŸ“š DocumentaciÃ³n Interactiva

FastAPI genera automÃ¡ticamente documentaciÃ³n interactiva:

### Swagger UI (OpenAPI)
**URL:** http://127.0.0.1:8000/docs

CaracterÃ­sticas:
- âœ… Interfaz visual para probar endpoints
- âœ… BotÃ³n "Authorize" para login con JWT
- âœ… GeneraciÃ³n automÃ¡tica de requests
- âœ… VisualizaciÃ³n de respuestas en tiempo real

### ReDoc
**URL:** http://127.0.0.1:8000/redoc

CaracterÃ­sticas:
- âœ… DocumentaciÃ³n clara y organizada
- âœ… ExportaciÃ³n a PDF
- âœ… BÃºsqueda de endpoints

### CÃ³mo Usar Swagger UI con AutenticaciÃ³n

1. Abrir http://127.0.0.1:8000/docs
2. Expandir endpoint `POST /auth/login`
3. Click en "Try it out"
4. Ingresar credenciales (`admin` / `admin123`)
5. Click "Execute"
6. Copiar el `access_token` de la respuesta
7. Click en botÃ³n "Authorize" (ğŸ”’ arriba a la derecha)
8. Pegar token en el campo y click "Authorize"
9. Ahora puedes probar endpoints protegidos

---

## âœ¨ Buenas PrÃ¡cticas Implementadas

### 1. Arquitectura en Capas
- SeparaciÃ³n clara de responsabilidades
- CÃ³digo modular y reutilizable
- FÃ¡cil de testear y mantener

### 2. ValidaciÃ³n de Datos
- Uso de Pydantic para validaciÃ³n automÃ¡tica
- Validators personalizados con regex
- Mensajes de error claros y especÃ­ficos

### 3. Seguridad
- âœ… ContraseÃ±as hasheadas con bcrypt (nunca en texto plano)
- âœ… JWT firmados con SECRET_KEY segura
- âœ… Tokens con expiraciÃ³n configurable
- âœ… Control de acceso basado en roles
- âœ… Variables sensibles en `.env` (excluidas de git)

### 4. Manejo de Errores
- CÃ³digos HTTP apropiados (200, 201, 401, 403, 404, 409, 422, 500)
- Mensajes descriptivos para el cliente
- Captura de errores especÃ­ficos de MySQL

### 5. CORS Configurado
- Preparado para integraciÃ³n con frontends
- Configurable para producciÃ³n

### 6. DocumentaciÃ³n
- CÃ³digo autodocumentado con docstrings
- OpenAPI/Swagger automÃ¡tico
- README completo y actualizado

### 7. Variables de Entorno
- ConfiguraciÃ³n centralizada en `config.py`
- Uso de `.env` para secretos
- `.env.example` como plantilla

---

## ğŸ”§ SoluciÃ³n de Problemas

### Error: "python-multipart" requerido

**Problema:**
```
RuntimeError: Form data requires "python-multipart" to be installed
```

**SoluciÃ³n:**
```bash
pip install python-multipart
```

### Error: ConexiÃ³n a MySQL rechazada

**Problema:**
```
Error al conectar a MySQL: Access denied
```

**SoluciÃ³n:

## ğŸ“ Estructura del Proyecto

```
clientes_api/
â”‚
â”œâ”€â”€ app/                          # Paquete principal de la aplicaciÃ³n
â”‚   â”œâ”€â”€ __init__.py              # Inicializa el paquete
â”‚   â”œâ”€â”€ main.py                  # Punto de entrada de la aplicaciÃ³n
â”‚   â”œâ”€â”€ database.py              # Funciones de acceso a datos
â”‚   â”‚
â”‚   â”œâ”€â”€ routers/                 # MÃ³dulo de rutas/endpoints
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ clientes.py          # Endpoints de gestiÃ³n de clientes
â”‚   â”‚
â”‚   â””â”€â”€ schemas/                 # MÃ³dulo de modelos de datos
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ cliente.py           # Modelos Pydantic para clientes
â”‚
â”œâ”€â”€ docs/                         # DocumentaciÃ³n y scripts SQL
â”‚   â””â”€â”€ init_db.sql              # Script de inicializaciÃ³n de BD
â”‚
â”œâ”€â”€ .env                         # Variables de entorno (NO versionar)
â”œâ”€â”€ requirements.txt             # Dependencias del proyecto
â””â”€â”€ README.md                    # Este archivo
```

### DescripciÃ³n de Archivos Clave:

#### ğŸ“„ `app/main.py`
Archivo principal que:
- Inicializa la aplicaciÃ³n FastAPI
- Configura CORS para permitir peticiones desde el frontend
- Registra los routers (endpoints)
- Define el endpoint raÃ­z

#### ğŸ“„ `app/database.py`
Contiene las funciones de acceso a datos:
- `get_connection()`: Establece conexiÃ³n con MySQL
- `get_all_clientes()`: Obtiene todos los clientes
- `get_cliente_by_id()`: Obtiene un cliente por ID
- `create_cliente()`: Inserta un nuevo cliente
- `update_cliente()`: Actualiza un cliente existente
- `delete_cliente()`: Elimina un cliente

#### ğŸ“„ `app/routers/clientes.py`
Define los endpoints de la API:
- `GET /clientes`: Listar todos los clientes
- `GET /clientes/{id}`: Obtener un cliente especÃ­fico
- `POST /clientes`: Crear un nuevo cliente
- `PUT /clientes/{id}`: Actualizar un cliente
- `DELETE /clientes/{id}`: Eliminar un cliente

#### ğŸ“„ `app/schemas/cliente.py`
Define los modelos de datos con Pydantic:
- `ClienteBase`: Modelo base con validaciones comunes
- `ClienteCreate`: Para crear nuevos clientes
- `ClienteUpdate`: Para actualizar clientes existentes
- `ClienteResponse`: Para las respuestas de la API
- `ClienteDB`: Representa los datos almacenados en BD

---

## ğŸ’¡ Conceptos Clave

### 1ï¸âƒ£ API REST
**REST** (Representational State Transfer) es un estilo de arquitectura que utiliza HTTP para la comunicaciÃ³n entre cliente y servidor.

**CaracterÃ­sticas:**
- Usa mÃ©todos HTTP estÃ¡ndar (GET, POST, PUT, DELETE)
- Recursos identificados por URLs
- Sin estado (stateless)
- Formato JSON para intercambio de datos

### 2ï¸âƒ£ CRUD Operations
**CRUD** = Create, Read, Update, Delete

| OperaciÃ³n | MÃ©todo HTTP | Endpoint | DescripciÃ³n |
|-----------|-------------|----------|-------------|
| **Create** | POST | `/clientes` | Crear nuevo cliente |
| **Read** | GET | `/clientes` | Listar todos los clientes |
| **Read** | GET | `/clientes/{id}` | Obtener un cliente |
| **Update** | PUT | `/clientes/{id}` | Actualizar cliente |
| **Delete** | DELETE | `/clientes/{id}` | Eliminar cliente |

### 3ï¸âƒ£ CÃ³digos de Estado HTTP

| CÃ³digo | Significado | Uso en el Proyecto |
|--------|-------------|-------------------|
| **200** | OK | Respuesta exitosa (GET, PUT) |
| **201** | Created | Cliente creado exitosamente |
| **204** | No Content | Cliente eliminado (sin contenido) |
| **404** | Not Found | Cliente no encontrado |
| **409** | Conflict | Email duplicado |
| **422** | Unprocessable Entity | Error de validaciÃ³n |
| **500** | Internal Server Error | Error del servidor |

### 4ï¸âƒ£ Pydantic Models
Pydantic es una librerÃ­a para validaciÃ³n de datos usando type hints de Python.

**Ventajas:**
- ValidaciÃ³n automÃ¡tica de tipos
- Mensajes de error descriptivos
- ConversiÃ³n automÃ¡tica de datos
- DocumentaciÃ³n automÃ¡tica en Swagger

### 5ï¸âƒ£ Dependency Injection

**SoluciÃ³n:**
1. Verificar credenciales en el archivo `.env`
2. Verificar que MySQL estÃ© corriendo:
   ```bash
   sudo systemctl status mysql
   ```
3. Verificar que la base de datos `clientes_db` existe:
   ```bash
   mysql -u root -p -e "SHOW DATABASES;"
   ```

### Error: SECRET_KEY no definida

**Problema:**
```
RuntimeError: SECRET_KEY no estÃ¡ definida en el archivo .env
```

**SoluciÃ³n:**
1. Crear archivo `.env` si no existe
2. Agregar la lÃ­nea:
   ```env
   SECRET_KEY=tu_clave_generada_con_secrets
   ```
3. Generar clave segura:
   ```bash
   python -c "import secrets; print(secrets.token_hex(32))"
   ```

### Error: Token invÃ¡lido o expirado

**Problema:**
```
401 Unauthorized: Token invÃ¡lido o expirado
```

**SoluciÃ³n:**
1. Verificar que el token se estÃ¡ enviando correctamente en el header:
   ```
   Authorization: Bearer <token>
   ```
2. El token expira segÃºn `ACCESS_TOKEN_EXPIRE_MINUTES` en `.env`
3. Hacer login nuevamente para obtener un nuevo token

### Error: Permisos insuficientes (403)

**Problema:**
```
403 Forbidden: Permisos insuficientes
```

**SoluciÃ³n:**
- El usuario `lector` solo puede hacer GET
- Usa el usuario `admin` para operaciones de escritura (POST, PUT, DELETE)

### El servidor no se levanta

**Problema:** El comando `uvicorn` no funciona

**SoluciÃ³n:**
```bash
# AsegÃºrate de estar en el entorno virtual
source .venv/bin/activate  # Linux/Mac
.venv\Scripts\activate     # Windows

# Reinstalar uvicorn
pip install uvicorn --force-reinstall

# Ejecutar desde la raÃ­z del proyecto
uvicorn app.main:app --reload
```

---

## ğŸ¯ Casos de Uso y Ejemplos

### Caso 1: Sistema de Registro de Clientes para Tienda

**Escenario:** Una tienda quiere digitalizar el registro de sus clientes.

**Flujo:**
1. Empleado inicia sesiÃ³n con `admin` / `admin123`
2. Obtiene token JWT
3. Registra nuevo cliente con POST `/clientes/`
4. Consulta lista de clientes con GET `/clientes/`
5. Actualiza informaciÃ³n si hay cambios

### Caso 2: Portal de Consulta para Vendedores

**Escenario:** Vendedores necesitan consultar informaciÃ³n de clientes pero no modificarla.

**Flujo:**
1. Vendedor inicia sesiÃ³n con `lector` / `lector123`
2. Obtiene token JWT (con rol `lector`)
3. Consulta clientes (GET permitido)
4. Si intenta crear/modificar â†’ Error 403 Forbidden

---

## ğŸ“– Ejercicios Propuestos

### Nivel BÃ¡sico

1. **Agregar campo "activo"** a la tabla clientes
   - Modificar base de datos
   - Actualizar schemas
   - Implementar endpoint para activar/desactivar

2. **Endpoint de bÃºsqueda** por email
   - Crear `GET /clientes/search?email=...`
   - Implementar funciÃ³n en database.py

3. **PaginaciÃ³n** en listado de clientes
   - Agregar parÃ¡metros `skip` y `limit`
   - `GET /clientes?skip=0&limit=10`

### Nivel Intermedio

4. **Implementar bÃºsqueda avanzada**
   - Buscar por nombre, apellido o email
   - Soporte de filtros mÃºltiples

5. **Agregar timestamps** a clientes
   - `created_at` y `updated_at`
   - Actualizar automÃ¡ticamente

6. **Soft delete**
   - No eliminar fÃ­sicamente
   - Marcar como inactivo

### Nivel Avanzado

7. **Implementar refresh tokens**
   - Token de acceso corto (15 min)
   - Refresh token largo (7 dÃ­as)

8. **Rate limiting**
   - Limitar requests por IP
   - Prevenir abuso de la API

9. **Logging completo**
   - Registrar todas las operaciones
   - Logs estructurados con timestamps

---

## ğŸš€ PrÃ³ximos Pasos

### Mejoras Sugeridas

- [ ] **Testing**: Agregar tests unitarios con pytest
- [ ] **Migraciones**: Usar Alembic para gestionar cambios en BD
- [ ] **ORM**: Migrar a SQLAlchemy para mejor abstracciÃ³n
- [ ] **Cache**: Implementar Redis para mejorar performance
- [ ] **Async**: Usar driver async de MySQL
- [ ] **Docker**: Containerizar la aplicaciÃ³n
- [ ] **CI/CD**: Automatizar despliegue con GitHub Actions
- [ ] **Monitoring**: Agregar mÃ©tricas y observabilidad

### IntegraciÃ³n con Frontend

Este backend estÃ¡ listo para conectarse con:
- **React**: Usando axios o fetch
- **Vue.js**: Usando axios o Vue Resource
- **Angular**: Usando HttpClient
- **Flutter/React Native**: Para apps mÃ³viles

**Ejemplo de consumo desde JavaScript:**
```javascript
// Login
const response = await fetch('http://127.0.0.1:8000/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: 'username=admin&password=admin123'
});
const { access_token } = await response.json();

// Obtener clientes con autenticaciÃ³n
const clientes = await fetch('http://127.0.0.1:8000/clientes/', {
  headers: { 'Authorization': `Bearer ${access_token}` }
});
```

---

## ğŸ“š Recursos Adicionales

### DocumentaciÃ³n Oficial

- **FastAPI**: https://fastapi.tiangolo.com/
- **Pydantic**: https://docs.pydantic.dev/
- **MySQL Connector**: https://dev.mysql.com/doc/connector-python/en/
- **JWT (Python-Jose)**: https://python-jose.readthedocs.io/
- **Passlib**: https://passlib.readthedocs.io/

### Tutoriales Recomendados

- [FastAPI Tutorial Oficial](https://fastapi.tiangolo.com/tutorial/)
- [Pydantic Field Validators](https://docs.pydantic.dev/latest/concepts/validators/)
- [JWT Authentication en FastAPI](https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/)
- [SQL con Python](https://realpython.com/python-sql-libraries/)

### Videos Educativos

- FastAPI - A Python Framework Full Course (freeCodeCamp)
- Building REST APIs with FastAPI (TechWithTim)
- JWT Authentication Tutorial (Pretty Printed)

---

## ğŸ“ Notas Finales

### Seguridad en ProducciÃ³n

âš ï¸ **IMPORTANTE**: Este proyecto es educativo. Para producciÃ³n considera:

1. **Variables de entorno seguras**: No usar valores por defecto
2. **HTTPS**: Siempre usar SSL/TLS
3. **CORS especÃ­fico**: No usar `allow_origins=["*"]`
4. **Rate limiting**: Limitar requests por IP
5. **Logging y monitoring**: Implementar observabilidad
6. **ValidaciÃ³n adicional**: SanitizaciÃ³n de inputs
7. **Secretos seguros**: Usar gestores de secretos (AWS Secrets Manager, HashiCorp Vault)

### Licencia

Este proyecto es de cÃ³digo abierto con fines educativos.

### Contribuciones

Las contribuciones son bienvenidas:
1. Fork el proyecto
2. Crea una rama para tu feature (`git checkout -b feature/AmazingFeature`)
3. Commit tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

---

## ğŸ‘¨â€ğŸ’» Autor

**Juan Carlos SulbarÃ¡n GonzÃ¡lez**

---

## ğŸ™ Agradecimientos

- Comunidad de FastAPI
- DocumentaciÃ³n de Pydantic
- Estudiantes que han probado y mejorado este proyecto

---

<div align="center">

**Â¿Preguntas o sugerencias?**

Abre un issue en el repositorio o contacta al autor.

â­ Si este proyecto te fue Ãºtil, dale una estrella â­

**Ãšltima actualizaciÃ³n:** 6 de enero de 2026

</div>

DB_PASSWORD=tu_contraseÃ±a_mysql
DB_NAME=clientes_db
```

âš ï¸ **IMPORTANTE**: Nunca subir el archivo `.env` a repositorios pÃºblicos (agregar a `.gitignore`)

### Paso 5: Verificar InstalaciÃ³n

```bash
# Ver paquetes instalados
pip list

# Verificar conexiÃ³n a la BD (opcional)
python -c "from app.database import get_connection; print('OK' if get_connection() else 'ERROR')"
```

---

## â–¶ï¸ EjecuciÃ³n del Proyecto

### Modo Desarrollo

```bash
# AsegÃºrate de estar en el directorio del proyecto
# y tener el entorno virtual activado

uvicorn app.main:app --reload
```

**ParÃ¡metros:**
- `app.main:app`: Indica el mÃ³dulo y la instancia de FastAPI
- `--reload`: Recarga automÃ¡ticamente al detectar cambios (solo desarrollo)

### Salida Esperada:

```
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process
INFO:     Started server process
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

### Acceder a la AplicaciÃ³n:

| URL | DescripciÃ³n |
|-----|-------------|
| http://127.0.0.1:8000 | Endpoint raÃ­z |
| http://127.0.0.1:8000/docs | **Swagger UI** - DocumentaciÃ³n interactiva |
| http://127.0.0.1:8000/redoc | **ReDoc** - DocumentaciÃ³n alternativa |

### Modo ProducciÃ³n

```bash
uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4
```

**ParÃ¡metros adicionales:**
- `--host 0.0.0.0`: Acepta conexiones externas
- `--port 8000`: Puerto de escucha
- `--workers 4`: NÃºmero de procesos worker

---

## ğŸŒ API Endpoints

### 1ï¸âƒ£ Listar Todos los Clientes

```http
GET /clientes
```

**Respuesta Exitosa (200):**
```json
[
  {
    "id": 1,
    "nombre": "Juan",
    "apellido": "PÃ©rez",
    "email": "juan.perez@example.com",
    "telefono": "555-0101",
    "direccion": "Calle 123, Ciudad"
  },
  ...
]
```

### 2ï¸âƒ£ Obtener Un Cliente EspecÃ­fico

```http
GET /clientes/{id}
```

**ParÃ¡metros:**
- `id` (path): ID del cliente

**Respuesta Exitosa (200):**
```json
{
  "id": 1,
  "nombre": "Juan",
  "apellido": "PÃ©rez",
  "email": "juan.perez@example.com",
  "telefono": "555-0101",
  "direccion": "Calle 123, Ciudad"
}
```

**Respuesta Error (404):**
```json
{
  "detail": "Cliente no encontrado"
}
```

### 3ï¸âƒ£ Crear Nuevo Cliente

```http
POST /clientes
Content-Type: application/json
```

**Cuerpo de la PeticiÃ³n:**
```json
{
  "nombre": "Pedro",
  "apellido": "GonzÃ¡lez",
  "email": "pedro.gonzalez@example.com",
  "telefono": "+34 612345678",
  "direccion": "Av. Principal 456"
}
```

**Campos Obligatorios:**
- `nombre` âœ…
- `apellido` âœ…
- `email` âœ…

**Campos Opcionales:**
- `telefono` (puede ser `null` o vacÃ­o)
- `direccion` (puede ser `null` o vacÃ­o)

**Respuesta Exitosa (201):**
```json
{
  "id": 6,
  "nombre": "Pedro",
  "apellido": "GonzÃ¡lez",
  "email": "pedro.gonzalez@example.com",
  "telefono": "+34 612345678",
  "direccion": "Av. Principal 456"
}
```

**Respuesta Error - Email Duplicado (409):**
```json
{
  "detail": "Ya existe un cliente con ese email"
}
```

**Respuesta Error - ValidaciÃ³n (422):**
```json
{
  "detail": [
    {
      "type": "string_too_short",
      "loc": ["body", "nombre"],
      "msg": "Debe tener al menos 2 caracteres"
    }
  ]
}
```

### 4ï¸âƒ£ Actualizar Cliente

```http
PUT /clientes/{id}
Content-Type: application/json
```

**ParÃ¡metros:**
- `id` (path): ID del cliente a actualizar

**Cuerpo de la PeticiÃ³n:**
```json
{
  "nombre": "Pedro",
  "apellido": "GonzÃ¡lez SÃ¡nchez",
  "email": "pedro.gonzalez@example.com",
  "telefono": "+34 687654321",
  "direccion": "Nueva DirecciÃ³n 789"
}
```

**Respuesta Exitosa (200):**
```json
{
  "id": 6,
  "nombre": "Pedro",
  "apellido": "GonzÃ¡lez SÃ¡nchez",
  "email": "pedro.gonzalez@example.com",
  "telefono": "+34 687654321",
  "direccion": "Nueva DirecciÃ³n 789"
}
```

### 5ï¸âƒ£ Eliminar Cliente

```http
DELETE /clientes/{id}
```

**ParÃ¡metros:**
- `id` (path): ID del cliente a eliminar

**Respuesta Exitosa (204):**
Sin contenido

**Respuesta Error (404):**
```json
{
  "detail": "Cliente no encontrado"
}
```

---

## âœ… Validaciones Implementadas

### Campo: `nombre` y `apellido`

| Regla | DescripciÃ³n | Ejemplo VÃ¡lido | Ejemplo InvÃ¡lido |
|-------|-------------|----------------|------------------|
| **No vacÃ­o** | No puede estar vacÃ­o | "Juan" | "" o "   " |
| **Longitud mÃ­nima** | Al menos 2 caracteres | "Li" | "J" |
| **Longitud mÃ¡xima** | MÃ¡ximo 50 caracteres | "Juan Carlos" | (Cadena > 50) |
| **Solo letras** | Letras, espacios y acentos | "JosÃ© MarÃ­a" | "Juan123" |
| **CapitalizaciÃ³n** | Convierte a Title Case | "JUAN" â†’ "Juan" | - |

### Campo: `email`

| Regla | DescripciÃ³n | Ejemplo VÃ¡lido | Ejemplo InvÃ¡lido |
|-------|-------------|----------------|------------------|
| **Formato vÃ¡lido** | Email bien formado | "user@example.com" | "user@" o "user.com" |
| **Ãšnico en BD** | No puede repetirse | "nuevo@example.com" | (Email existente) |

### Campo: `telefono` (opcional)

| Regla | DescripciÃ³n | Ejemplo VÃ¡lido | Ejemplo InvÃ¡lido |
|-------|-------------|----------------|------------------|
| **Formato** | 7-15 dÃ­gitos | "+34 612345678" | "123" |
| **Caracteres permitidos** | NÃºmeros, +, -, (), espacios | "555-0101" | "abc123" |
| **Limpieza** | Elimina espacios y guiones | "555 - 0101" â†’ validado | - |

### Campo: `direccion` (opcional)

| Regla | DescripciÃ³n | Ejemplo VÃ¡lido | Ejemplo InvÃ¡lido |
|-------|-------------|----------------|------------------|
| **Longitud mÃ¡xima** | MÃ¡ximo 200 caracteres | "Calle 123, Piso 4" | (Cadena > 200) |

### Validaciones a Nivel de Base de Datos

```sql
CREATE TABLE clientes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,           -- No nulo
    apellido VARCHAR(100) NOT NULL,         -- No nulo
    email VARCHAR(150) NOT NULL UNIQUE,     -- No nulo y Ãºnico
    telefono VARCHAR(50),                   -- Opcional
    direccion VARCHAR(255)                  -- Opcional
);
```

---

## ğŸš¨ Manejo de Errores

### Estrategia de Manejo de Errores

El proyecto implementa un manejo robusto de errores en mÃºltiples niveles:

#### 1ï¸âƒ£ Errores de ValidaciÃ³n (422)

FastAPI + Pydantic validan automÃ¡ticamente:
- Tipos de datos incorrectos
- Campos requeridos faltantes
- Formatos invÃ¡lidos

```json
{
  "detail": [
    {
      "type": "value_error",
      "loc": ["body", "nombre"],
      "msg": "Debe tener al menos 2 caracteres",
      "input": "J"
    }
  ]
}
```

#### 2ï¸âƒ£ Errores de Negocio

**Cliente no encontrado (404):**
```python
if not cliente:
    raise HTTPException(
        status_code=404,
        detail="Cliente no encontrado"
    )
```

**Email duplicado (409):**
```python
if e.errno == 1062:  # MySQL duplicate entry
    raise HTTPException(
        status_code=status.HTTP_409_CONFLICT,
        detail="Ya existe un cliente con ese email"
    )
```

#### 3ï¸âƒ£ Errores de ConexiÃ³n (500)

```python
def get_connection():
    try:
        connection = mysql.connector.connect(...)
        return connection
    except Error as e:
        print(f"Error al conectar a MySQL: {e}")
        return None
```

### Tabla de Errores Comunes

| Error | Causa | SoluciÃ³n |
|-------|-------|----------|
| **ConnectionError** | No se puede conectar a MySQL | Verificar servicio MySQL, credenciales en `.env` |
| **404 Not Found** | ID de cliente inexistente | Verificar que el ID existe en la BD |
| **409 Conflict** | Email ya registrado | Usar un email diferente |
| **422 Validation Error** | Datos invÃ¡lidos en el body | Revisar formato y campos requeridos |
| **500 Internal Server** | Error en el servidor | Revisar logs de Uvicorn |

---

## ğŸ† Buenas PrÃ¡cticas Aplicadas

### 1ï¸âƒ£ OrganizaciÃ³n del CÃ³digo

âœ… **SeparaciÃ³n por responsabilidades:**
- Routers â†’ Endpoints
- Schemas â†’ Validaciones
- Database â†’ Acceso a datos

### 2ï¸âƒ£ Nomenclatura

âœ… **Convenciones Python (PEP 8):**
- `snake_case` para funciones y variables
- `PascalCase` para clases
- Nombres descriptivos

```python
# âœ… Correcto
def get_cliente_by_id(cliente_id: int):
    ...

# âŒ Incorrecto
def getClient(id):
    ...
```

### 3ï¸âƒ£ Type Hints

âœ… **Uso de anotaciones de tipo:**

```python
def create_cliente(data: dict) -> int:
    ...
```

### 4ï¸âƒ£ ValidaciÃ³n de Datos

âœ… **Validaciones exhaustivas con Pydantic**
âœ… **Mensajes de error descriptivos**

### 5ï¸âƒ£ Seguridad

âœ… **Variables de entorno** para credenciales
âœ… **Prepared statements** (protecciÃ³n contra SQL injection)
âœ… **ValidaciÃ³n de email Ãºnico**

```python
# âœ… Prepared statement
cursor.execute("SELECT * FROM clientes WHERE id = %s", (cliente_id,))

# âŒ ConcatenaciÃ³n (vulnerable a SQL injection)
cursor.execute(f"SELECT * FROM clientes WHERE id = {cliente_id}")
```

### 6ï¸âƒ£ DocumentaciÃ³n

âœ… **Comentarios explicativos**
âœ… **Docstrings** (cuando es necesario)
âœ… **DocumentaciÃ³n automÃ¡tica** (Swagger/OpenAPI)

### 7ï¸âƒ£ Manejo de Recursos

âœ… **Cerrar conexiones:**

```python
cursor.close()
conn.close()
```

### 8ï¸âƒ£ CÃ³digos HTTP Apropiados

âœ… **200** para GET/PUT exitosos
âœ… **201** para POST exitosos
âœ… **204** para DELETE exitosos
âœ… **404** para recursos no encontrados
âœ… **409** para conflictos

---

## ğŸ¯ Ejercicios Propuestos

### Nivel BÃ¡sico

1. **Agregar un nuevo campo:**
   - AÃ±adir campo `fecha_nacimiento` a la tabla y modelo
   - Implementar validaciÃ³n (mayor de 18 aÃ±os)

2. **Endpoint de bÃºsqueda:**
   - Crear `GET /clientes/buscar?email=...`
   - Buscar cliente por email

3. **PaginaciÃ³n:**
   - Modificar `GET /clientes` para aceptar parÃ¡metros `limit` y `offset`
   - Implementar paginaciÃ³n en la consulta SQL

### Nivel Intermedio

4. **Endpoint de estadÃ­sticas:**
   - Crear `GET /clientes/estadisticas`
   - Retornar: total de clientes, clientes por dominio de email, etc.

5. **Soft Delete:**
   - Agregar campo `activo` (boolean)
   - Modificar DELETE para marcar como inactivo en vez de eliminar
   - Filtrar clientes inactivos en GET

6. **Logging:**
   - Implementar logging con el mÃ³dulo `logging`
   - Registrar todas las operaciones CRUD

### Nivel Avanzado

7. **AutenticaciÃ³n:**
   - Agregar JWT authentication
   - Proteger endpoints (excepto GET)

8. **Testing:**
   - Escribir tests unitarios con `pytest`
   - Tests de integraciÃ³n para los endpoints

9. **Segunda entidad:**
   - Crear entidad `Pedidos`
   - RelaciÃ³n: Un cliente tiene muchos pedidos
   - Implementar CRUD completo

10. **Migraciones:**
    - Usar `Alembic` para gestionar cambios en la BD
    - Crear script de migraciÃ³n para agregar nuevo campo

---

## ğŸ“š Recursos Adicionales

### DocumentaciÃ³n Oficial

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [MySQL Connector/Python](https://dev.mysql.com/doc/connector-python/en/)
- [Uvicorn Documentation](https://www.uvicorn.org/)

### Tutoriales y GuÃ­as

- [FastAPI Tutorial](https://fastapi.tiangolo.com/tutorial/)
- [Real Python - FastAPI](https://realpython.com/fastapi-python-web-apis/)
- [HTTP Status Codes](https://httpstatuses.com/)
- [REST API Design](https://restfulapi.net/)

### Herramientas Recomendadas

- **Postman**: Testing de APIs
- **DBeaver**: Cliente de bases de datos
- **VS Code Extensions**:
  - Python
  - Pylance
  - Thunder Client
  - MySQL

### Videos Educativos

- [Curso FastAPI (YouTube)](https://www.youtube.com/results?search_query=fastapi+tutorial+espaÃ±ol)
- [REST API Concepts](https://www.youtube.com/results?search_query=rest+api+concepts)

---

## ğŸ¤ Contribuciones

Este proyecto es educativo. Se anima a los estudiantes a:

- Reportar bugs
- Proponer mejoras
- Hacer fork y experimentar
- Compartir aprendizajes

---

## ğŸ“ Licencia

Este proyecto es de uso educativo y libre distribuciÃ³n.

---

## âœ‰ï¸ Contacto

**Autor:** Juan Carlos SulbarÃ¡n GonzÃ¡lez  
**PropÃ³sito:** Material educativo para DAW/DAM  
**Fecha:** 2025

---

## ğŸ™ Agradecimientos

A todos los estudiantes que utilicen este proyecto como recurso de aprendizaje. Â¡Mucho Ã©xito en su formaciÃ³n como desarrolladores!

---

**Â¡Happy Coding! ğŸš€**

```

requirements.txt
-----
```
annotated-doc==0.0.4
annotated-types==0.7.0
anyio==4.12.0
bcrypt==3.2.2
black==25.12.0
cffi==2.0.0
click==8.3.1
cryptography==46.0.3
dnspython==2.8.0
ecdsa==0.19.1
email-validator==2.3.0
fastapi==0.128.0
h11==0.16.0
idna==3.11
mypy_extensions==1.1.0
mysql-connector-python==9.5.0
packaging==25.0
passlib==1.7.4
pathspec==0.12.1
platformdirs==4.5.1
pyasn1==0.6.1
pycparser==2.23
pydantic==2.12.5
pydantic_core==2.41.5
python-dotenv==1.2.1
python-jose==3.5.0
python-multipart==0.0.21
pytokens==0.3.0
rsa==4.9.1
six==1.17.0
starlette==0.50.0
typing-inspection==0.4.2
typing_extensions==4.15.0
uvicorn==0.40.0

```

app/auth/deps.py
-----
```python
from typing import Dict

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.auth.jwt import decode_access_token

# OAuth2 con Bearer Token
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")


def get_current_user(token: str = Depends(oauth2_scheme)) -> Dict:
    """
    Extrae y valida el usuario actual desde el JWT.
    """
    try:
        payload = decode_access_token(token)
        username = payload.get("sub")
        role = payload.get("role")

        if not username or not role:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token invÃ¡lido"
            )

        return {
            "username": username,
            "role": role
        }

    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token invÃ¡lido o expirado"
        )


def require_admin(user: Dict = Depends(get_current_user)) -> Dict:
    """
    Verifica que el usuario tenga rol administrador.
    """
    if user["role"] != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Permisos insuficientes"
        )
    return user

```

app/auth/jwt.py
-----
```python
from datetime import datetime, timedelta
from typing import Any, Dict

from jose import JWTError, jwt

from app.core.config import settings


def create_access_token(
    data: Dict[str, Any],
    expires_delta: timedelta | None = None
) -> str:
    """
    Crea un JWT firmado con fecha de expiraciÃ³n.
    """
    to_encode = data.copy()

    expire = (
        datetime.utcnow() + expires_delta
        if expires_delta
        else datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    )

    to_encode.update({"exp": expire})

    encoded_jwt = jwt.encode(
        to_encode,
        settings.SECRET_KEY,
        algorithm=settings.ALGORITHM
    )

    return encoded_jwt


def decode_access_token(token: str) -> Dict[str, Any]:
    """
    Decodifica y valida un JWT.
    Lanza excepciÃ³n si es invÃ¡lido o expirÃ³.
    """
    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM]
        )
        return payload
    except JWTError as exc:
        raise ValueError("Token invÃ¡lido o expirado") from exc

```

app/auth/passwords.py
-----
```python
from passlib.context import CryptContext

# Contexto de hashing
pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto"
)


def hash_password(password: str) -> str:
    """
    Recibe una contraseÃ±a en texto plano
    y devuelve su hash seguro.
    """
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifica si una contraseÃ±a en texto plano
    coincide con su hash almacenado.
    """
    return pwd_context.verify(plain_password, hashed_password)

```

app/core/config.py
-----
```python
import os
from dotenv import load_dotenv

load_dotenv()


class Settings:
    SECRET_KEY: str
    ALGORITHM: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int

    def __init__(self) -> None:
        secret_key = os.getenv("SECRET_KEY")
        if not secret_key:
            raise RuntimeError("SECRET_KEY no estÃ¡ definida en el archivo .env")

        self.SECRET_KEY = secret_key
        self.ALGORITHM = os.getenv("ALGORITHM", "HS256")
        self.ACCESS_TOKEN_EXPIRE_MINUTES = int(
            os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 60)
        )


settings = Settings()

```

app/database.py
-----
```python
# app/database.py

import mysql.connector
from mysql.connector import Error
from dotenv import load_dotenv
import os

load_dotenv()

def get_connection():
    try:
        connection = mysql.connector.connect(
            host=os.getenv("DB_HOST"),
            user=os.getenv("DB_USER"),
            password=os.getenv("DB_PASSWORD"),
            database=os.getenv("DB_NAME")
        )
        return connection
    except Error as e:
        print(f"Error al conectar a MySQL: {e}")
        return None


def get_all_clientes():
    conn = get_connection()
    if not conn:
        raise Exception("No se pudo conectar a la base de datos")
    
    cursor = conn.cursor(dictionary=True)

    cursor.execute("SELECT * FROM clientes")
    resultados = cursor.fetchall()

    cursor.close()
    conn.close()
    return resultados


def get_cliente_by_id(cliente_id: int):
    conn = get_connection()
    if not conn:
        raise Exception("No se pudo conectar a la base de datos")
    
    cursor = conn.cursor(dictionary=True)

    cursor.execute("SELECT * FROM clientes WHERE id = %s", (cliente_id,))
    resultado = cursor.fetchone()

    cursor.close()
    conn.close()
    return resultado


def create_cliente(data: dict):
    conn = get_connection()
    if not conn:
        raise Exception("No se pudo conectar a la base de datos")
    
    cursor = conn.cursor()

    query = """
        INSERT INTO clientes (nombre, apellido, email, telefono, direccion)
        VALUES (%s, %s, %s, %s, %s)
    """
    values = (
        data["nombre"],
        data["apellido"],
        data["email"],
        data.get("telefono"),
        data.get("direccion")
    )

    cursor.execute(query, values)
    conn.commit()

    new_id = cursor.lastrowid

    cursor.close()
    conn.close()
    return new_id


def update_cliente(cliente_id: int, data: dict) -> bool:
    conn = get_connection()
    if not conn:
        raise Exception("No se pudo conectar a la base de datos")
    
    cursor = conn.cursor()

    query = """
        UPDATE clientes
        SET nombre=%s, apellido=%s, email=%s, telefono=%s, direccion=%s
        WHERE id=%s
    """

    values = (
        data["nombre"],
        data["apellido"],
        data["email"],
        data.get("telefono") if data.get("telefono") else None,
        data.get("direccion") if data.get("direccion") else None,
        cliente_id
    )

    cursor.execute(query, values)
    conn.commit()

    actualizado = cursor.rowcount > 0

    cursor.close()
    conn.close()

    return actualizado


def delete_cliente(cliente_id: int):
    conn = get_connection()
    if not conn:
        raise Exception("No se pudo conectar a la base de datos")
    
    cursor = conn.cursor()

    cursor.execute("DELETE FROM clientes WHERE id=%s", (cliente_id,))
    conn.commit()

    affected = cursor.rowcount

    cursor.close()
    conn.close()
    return affected

```

app/main.py
-----
```python
# app/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.routers import clientes, auth

app = FastAPI(
    title="API de Clientes",
    version="1.0.0"
)

# CORS (pensando en React)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # en producciÃ³n se ajusta
    allow_credentials=False,  # False para permitir * en origins
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(clientes.router)
app.include_router(auth.router)


@app.get("/")
def root():
    return {
        "mensaje": "API de Clientes activa ğŸš€"
    }

```

app/repository/users_repo.py
-----
```python
from typing import Optional, Dict, Any, cast
from app.database import get_connection


def get_user_by_username(username: str) -> Optional[Dict[str, Any]]:
    conn = get_connection()
    assert conn is not None, "No se pudo obtener conexiÃ³n a la base de datos"

    cursor = conn.cursor(dictionary=True)

    query = """
        SELECT u.username, u.password_hash, r.nombre AS role
        FROM usuarios u
        JOIN roles r ON u.rol_id = r.id
        WHERE u.username = %s AND u.activo = 1
    """

    cursor.execute(query, (username,))
    user = cursor.fetchone()

    cursor.close()
    conn.close()

    if user is None:
        return None

    # Normalizamos el tipo para el resto de la aplicaciÃ³n
    return cast(Dict[str, Any], user)

```

app/routers/auth.py
-----
```python
# app/routers/auth.py
"""
Router de autenticaciÃ³n.

Implementa login mediante OAuth2 Password Flow
compatible con Swagger UI y JWT.
"""

from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import OAuth2PasswordRequestForm

from app.auth.passwords import verify_password
from app.auth.jwt import create_access_token
from app.repository.users_repo import get_user_by_username

router = APIRouter(
    prefix="/auth",
    tags=["Auth"]
)

# ======================================================
# POST /auth/login
# ======================================================
@router.post(
    "/login",
    summary="Login y generaciÃ³n de JWT",
    description="""
    AutenticaciÃ³n de usuario usando **OAuth2 Password Flow**.

    - Compatible con Swagger UI (Authorize)
    - Devuelve un JWT Bearer
    - Usa username y password
    """,
)
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    Autentica un usuario y devuelve un access_token JWT.
    """

    # 1ï¸âƒ£ Buscar usuario
    user = get_user_by_username(form_data.username)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales invÃ¡lidas",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 2ï¸âƒ£ Verificar password
    if not verify_password(form_data.password, user["password_hash"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales invÃ¡lidas",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 3ï¸âƒ£ Crear token
    access_token = create_access_token(
        data={
            "sub": user["username"],
            "role": user["role"]
        }
    )

    # 4ï¸âƒ£ Respuesta estÃ¡ndar OAuth2
    return {
        "access_token": access_token,
        "token_type": "bearer"
    }

```

app/routers/clientes.py
-----
```python
# app/routers/clientes.py

from fastapi import APIRouter, HTTPException, status, Depends
from typing import List, cast
from mysql.connector import Error

from app.auth.deps import require_admin
from app.schemas.cliente import (
    ClienteResponse,
    ClienteCreate,
    ClienteUpdate
)
from app.database import (
    get_all_clientes,
    get_cliente_by_id,
    create_cliente,
    update_cliente,
    delete_cliente
)

router = APIRouter(
    prefix="/clientes",
    tags=["Clientes"]
)

# =========================
# GET /clientes (PÃšBLICO)
# =========================
@router.get("/", response_model=List[ClienteResponse])
def listar_clientes():
    return get_all_clientes()


# =========================
# GET /clientes/{id} (PÃšBLICO)
# =========================
@router.get("/{cliente_id}", response_model=ClienteResponse)
def obtener_cliente(cliente_id: int):
    cliente = get_cliente_by_id(cliente_id)

    if not cliente:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Cliente no encontrado"
        )

    return cliente


# =========================
# POST /clientes (ADMIN)
# =========================
@router.post(
    "/",
    response_model=ClienteResponse,
    status_code=status.HTTP_201_CREATED
)
def crear_cliente(
    cliente: ClienteCreate,
    _: dict = Depends(require_admin)
):
    try:
        nuevo_id = create_cliente(cliente.model_dump())

        # Cast explÃ­cito para el tipador (create_cliente devuelve el id)
        return get_cliente_by_id(cast(int, nuevo_id))

    except Error as e:
        # MySQL error code 1062 = Duplicate entry (email UNIQUE)
        if e.errno == 1062:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Ya existe un cliente con ese email"
            )

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al crear el cliente"
        )


# =========================
# PUT /clientes/{id} (ADMIN)
# =========================
@router.put(
    "/{cliente_id}",
    response_model=ClienteResponse,
    status_code=status.HTTP_200_OK
)
def actualizar_cliente(
    cliente_id: int,
    cliente: ClienteUpdate,
    _: dict = Depends(require_admin)
):
    existente = get_cliente_by_id(cliente_id)
    if not existente:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Cliente no encontrado"
        )

    try:
        actualizado = update_cliente(cliente_id, cliente.model_dump())

        if not actualizado:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Cliente no encontrado"
            )

        return get_cliente_by_id(cliente_id)

    except Error as e:
        if e.errno == 1062:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Ya existe otro cliente con ese email"
            )

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al actualizar el cliente"
        )


# =========================
# DELETE /clientes/{id} (ADMIN)
# =========================
@router.delete(
    "/{cliente_id}",
    status_code=status.HTTP_204_NO_CONTENT
)
def eliminar_cliente(
    cliente_id: int,
    _: dict = Depends(require_admin)
):
    existente = get_cliente_by_id(cliente_id)
    if not existente:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Cliente no encontrado"
        )

    try:
        eliminado = delete_cliente(cliente_id)

        if not eliminado:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Cliente no encontrado"
            )

        return None

    except Exception:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al eliminar el cliente"
        )

```

app/routers/clientes_old.py
-----
```python
# app/routers/clientes.py

from fastapi import APIRouter, HTTPException, status
from typing import List
from mysql.connector import Error

from app.schemas.cliente import (
    ClienteResponse,
    ClienteCreate,
    ClienteUpdate
)
from app.database import (
    get_all_clientes,
    get_cliente_by_id,
    create_cliente,
    update_cliente,
    delete_cliente
)

router = APIRouter(
    prefix="/clientes",
    tags=["Clientes"]
)


@router.get("/", response_model=List[ClienteResponse])
def listar_clientes():
    return get_all_clientes()


@router.get("/{cliente_id}", response_model=ClienteResponse)
def obtener_cliente(cliente_id: int):
    cliente = get_cliente_by_id(cliente_id)

    if not cliente:
        raise HTTPException(
            status_code=404,
            detail="Cliente no encontrado"
        )

    return cliente

# =========================
# POST /clientes
# =========================
@router.post(
    "/",
    response_model=ClienteResponse,
    status_code=status.HTTP_201_CREATED
)
def crear_cliente(cliente: ClienteCreate):
    try:
        nuevo_id = create_cliente(cliente.model_dump())

        cliente_creado = get_cliente_by_id(nuevo_id)
        return cliente_creado

    except Error as e:
        # MySQL error code 1062 = Duplicate entry (email UNIQUE)
        if e.errno == 1062:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Ya existe un cliente con ese email"
            )

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al crear el cliente"
        )
    
# =========================
# PUT /clientes/{id}
# =========================
@router.put(
    "/{cliente_id}",
    response_model=ClienteResponse,
    status_code=status.HTTP_200_OK
)
def actualizar_cliente(cliente_id: int, cliente: ClienteUpdate):
    # 1ï¸âƒ£ Verificamos que el cliente exista
    existente = get_cliente_by_id(cliente_id)
    if not existente:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Cliente no encontrado"
        )

    try:
        actualizado = update_cliente(cliente_id, cliente.model_dump())

        if not actualizado:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Cliente no encontrado"
            )

        return get_cliente_by_id(cliente_id)

    except Error as e:
        # Email duplicado
        if e.errno == 1062:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Ya existe otro cliente con ese email"
            )

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al actualizar el cliente"
        )
```

app/schemas/auth.py
-----
```python
from pydantic import BaseModel


class LoginRequest(BaseModel):
    username: str
    password: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"

```

app/schemas/cliente.py
-----
```python
# app/schemas/cliente.py

from pydantic import BaseModel, EmailStr, field_validator
from typing import Optional
import re


# =========================
# Modelo base con validaciones (idÃ©ntico al monolito)
# =========================
class ClienteBase(BaseModel):
    nombre: str
    apellido: str
    email: EmailStr
    telefono: Optional[str] = None
    direccion: Optional[str] = None

    @field_validator("nombre", "apellido")
    @classmethod
    def validar_nombre_apellido(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("El campo no puede estar vacÃ­o")

        v = v.strip()

        if len(v) < 2:
            raise ValueError("Debe tener al menos 2 caracteres")

        if len(v) > 50:
            raise ValueError("No puede exceder 50 caracteres")

        # Solo letras, espacios, tildes y caracteres del espaÃ±ol
        if not re.match(r"^[a-zA-ZÃ¡Ã©Ã­Ã³ÃºÃÃ‰ÃÃ“ÃšÃ±Ã‘Ã¼Ãœ\s]+$", v):
            raise ValueError("Solo se permiten letras y espacios")

        return v.title()

    @field_validator("telefono")
    @classmethod
    def validar_telefono(cls, v: Optional[str]) -> Optional[str]:
        if v is None or v.strip() == "":
            return None

        v = v.strip()

        telefono_limpio = re.sub(r"[\s\-\(\)]", "", v)

        if not re.match(r"^\+?\d{7,15}$", telefono_limpio):
            raise ValueError(
                "Formato de telÃ©fono invÃ¡lido. Debe contener entre 7 y 15 dÃ­gitos"
            )

        return v

    @field_validator("direccion")
    @classmethod
    def validar_direccion(cls, v: Optional[str]) -> Optional[str]:
        if v is None or v.strip() == "":
            return None

        v = v.strip()

        if len(v) > 200:
            raise ValueError("La direcciÃ³n no puede exceder 200 caracteres")

        return v


# =========================
# Modelo para datos histÃ³ricos (BD)
# ğŸ‘‰ sin validaciones estrictas
# =========================
class ClienteDB(BaseModel):
    id: int
    nombre: str
    apellido: str
    email: str
    telefono: Optional[str] = None
    direccion: Optional[str] = None


# =========================
# Modelo para creaciÃ³n (POST)
# =========================
class ClienteCreate(ClienteBase):
    pass


# =========================
# Modelo para actualizaciÃ³n (PUT)
# =========================
class ClienteUpdate(BaseModel):
    nombre: str
    apellido: str
    email: EmailStr
    telefono: Optional[str] = None
    direccion: Optional[str] = None

    @field_validator("nombre", "apellido")
    @classmethod
    def validar_nombre_apellido(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("El campo no puede estar vacÃ­o")

        v = v.strip()

        if len(v) < 2:
            raise ValueError("Debe tener al menos 2 caracteres")

        if len(v) > 50:
            raise ValueError("No puede exceder 50 caracteres")

        if not re.match(r"^[a-zA-ZÃ¡Ã©Ã­Ã³ÃºÃÃ‰ÃÃ“ÃšÃ±Ã‘Ã¼Ãœ\s]+$", v):
            raise ValueError("Solo se permiten letras y espacios")

        return v.title()

    @field_validator("telefono")
    @classmethod
    def validar_telefono(cls, v: Optional[str]) -> Optional[str]:
        if v is None or v == "" or (isinstance(v, str) and v.strip() == ""):
            return None

        v = v.strip()
        telefono_limpio = re.sub(r"[\s\-\(\)]", "", v)

        if not re.match(r"^\+?\d{7,15}$", telefono_limpio):
            raise ValueError(
                "Formato de telÃ©fono invÃ¡lido. Debe contener entre 7 y 15 dÃ­gitos"
            )

        return v

    @field_validator("direccion")
    @classmethod
    def validar_direccion(cls, v: Optional[str]) -> Optional[str]:
        if v is None or v == "" or (isinstance(v, str) and v.strip() == ""):
            return None

        v = v.strip()

        if len(v) > 200:
            raise ValueError("La direcciÃ³n no puede exceder 200 caracteres")

        return v


# =========================
# Modelo de respuesta API
# =========================
class ClienteResponse(ClienteBase):
    id: int

    class Config:
        from_attributes = True

```

.env.back
-----
```
DB_HOST=localhost
DB_USER=
DB_PASSWORD=
DB_NAME=clientes_db
```

.gitignore
-----
```
# Created by https://www.toptal.com/developers/gitignore/api/python
# Edit at https://www.toptal.com/developers/gitignore?templates=python

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

### Python Patch ###
# Poetry local configuration file - https://python-poetry.org/docs/configuration/#local-configuration
poetry.toml

# ruff
.ruff_cache/

# LSP config files
pyrightconfig.json

# End of https://www.toptal.com/developers/gitignore/api/python
.vscode

# FastAPI specific
*.db
.env.local
.env.*.local
logs/
*.log
# colector de proyecto pata IA
repositorio.txt
recolector.py

# Entorno virtual
.venv/

# Archivos temporales
__pycache__/
*.pyc

# Archivos del sistema
.DS_Store
Thumbs.db
```

docs/init_db.sql
-----
```sql
-- =========================================================
-- SCRIPT INICIALIZADOR DE BASE DE DATOS PARA EL PROYECTO CLIENTES
-- Autor: Juan Carlos SulbarÃ¡n GonzÃ¡lez
-- Fecha: 2025-11-12
-- DescripciÃ³n:
--   Este script elimina la base de datos si ya existe,
--   la crea desde cero e inicializa clientes, roles y usuarios.
-- =========================================================

-- 1ï¸âƒ£ Eliminar base de datos si existe
DROP DATABASE IF EXISTS clientes_db;

-- 2ï¸âƒ£ Crear base de datos
CREATE DATABASE clientes_db
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_general_ci;

-- 3ï¸âƒ£ Seleccionar la base de datos
USE clientes_db;

-- =========================================================
-- 4ï¸âƒ£ Tabla clientes
-- =========================================================
CREATE TABLE clientes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL,
  apellido VARCHAR(100) NOT NULL,
  email VARCHAR(150) NOT NULL UNIQUE,
  telefono VARCHAR(50),
  direccion VARCHAR(255)
);

-- =========================================================
-- 5ï¸âƒ£ Tabla roles
-- =========================================================
CREATE TABLE roles (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nombre VARCHAR(50) NOT NULL UNIQUE,
  descripcion VARCHAR(150)
);

-- =========================================================
-- 6ï¸âƒ£ Tabla usuarios
-- =========================================================
CREATE TABLE usuarios (
  id INT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  email VARCHAR(150) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  rol_id INT NOT NULL,
  activo TINYINT NOT NULL DEFAULT 1,
  creado_en TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  actualizado_en TIMESTAMP NULL DEFAULT NULL
    ON UPDATE CURRENT_TIMESTAMP,
  CONSTRAINT fk_usuarios_roles
    FOREIGN KEY (rol_id)
    REFERENCES roles(id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT
);


-- =========================================================
-- 7ï¸âƒ£ Datos iniciales de roles
-- =========================================================
INSERT INTO roles (nombre, descripcion) VALUES
  ('admin', 'Puede crear, modificar y eliminar clientes'),
  ('lector', 'Solo puede consultar y filtrar clientes');

-- =========================================================
-- 8ï¸âƒ£ Datos de ejemplo en clientes
-- =========================================================
INSERT INTO clientes (nombre, apellido, email, telefono, direccion) VALUES
('Juan', 'PÃ©rez', 'juan.perez@example.com', '555-0101', 'Calle 123, Ciudad'),
('MarÃ­a', 'GarcÃ­a', 'maria.garcia@example.com', '555-0102', 'Avenida 456, Ciudad'),
('Carlos', 'RodrÃ­guez', 'carlos.rodriguez@example.com', '555-0103', 'Plaza 789, Ciudad'),
('Ana', 'MartÃ­nez', 'ana.martinez@example.com', '555-0104', 'Paseo 321, Ciudad'),
('Luis', 'LÃ³pez', 'luis.lopez@example.com', '555-0105', 'Boulevard 654, Ciudad');

-- admin
INSERT INTO usuarios (username, email, password_hash, rol_id)
VALUES ('admin', 'admin@test.com', '$2b$12$1FERac3oRY3l2090Xl7EGuDzO4zUe9Nyowy3XLaZ2t6znkmwB9I76', 1);

-- lector
INSERT INTO usuarios (username, email, password_hash, rol_id)
VALUES ('lector', 'lector@test.com', '$2b$12$IBWpsxUBSMIhWALA3L3Fk.97qcrHZ7xEpbkyFmaBmBtn1hca/j3Em', 2);

-- =========================================================
-- 9ï¸âƒ£ VerificaciÃ³n
-- =========================================================
-- SELECT * FROM clientes;
-- SELECT * FROM roles;
SELECT * FROM usuarios;
SELECT username, password_hash, activo FROM usuarios;

```

